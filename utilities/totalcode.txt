#include <iostream>
#include <ctime>
#include <chrono>
#include <cctype>
#include "chimie/define.cpp"
using namespace std;

// welcome to chimie++!
void app() {
  Chimie::Init();
  // Begining dialog
  //Chimie::loading(25);
  cout << "         .        .   \n";
  cout << "/¯¯ |  | | |\\  /| | |¯¯¯¯      |       |      • \\|/\n";
  cout << "|   |--| | | \\/ | | |----   ---|--- ---|---      c )\n";
  cout << "\\__ |  | | |    | | |____      |       |      • /|\\  \n";
  cout << "Bienvenue a Chimie++ (version terminal)\n";
  cout << "La raison qu'il n'y a pas d'accents est que certains OS ne montrent pas bien les accents et ecrivent du griboulli.\n";
  cout << "Qu'aimerais-tu faire? (en passant, tu peux avoir une liste des commandes avec le mot 'aide') \n";

  string command;
  int times = 1;
  // UI principal
  while (true) {
    // get users command until sortir
    if (times > 1) {
      cout << "Entre une " << times << "eme commande: ";
    } else {
      cout << "Entre une commande: ";
    }
    cin >> command; cout << endl;
    command = Chimie::lowerString(command);
    if (command == "aide") {
      // list all commands
      cout << "Voici une liste de commande: \n \n";
      cout << "sortir: Fermer l'application \n \n";
      cout << "info: Te donne tout l'information necessaire a propos d'un element\n \n";
      cout << "importer: Importe un element sous format d'element dans fichier .txt (voir template.txt) a partir d'un chemin vers le fichier .txt\n \n";
      cout << "creer_compose: cree un compose ionique ou moleculaire equilibre a partire de deux elements \n \n";
      cout << "netoie: efface tout le texte qui est presentement sur l'ecran\n\n"; 
      cout << "trouver_gi: indique quel est le gaz inerte le plus proche de l'element\n\n";
      cout << "quiz: un outil de pratique pour la chimie\n\n";
      cout << "systeme: retourne le nom de ton OS \n\n";
      cout << "temps: indique l'heure exacte\n\n";
      cout << "tout: liste tout les elements";
      cout << "credits: montre les credits\n\n";
    } else if (command == "quiz") { 
      cout << "Quel niveau de difficulte? [facile, medium, difficile]\n\n";
      string difficulte; cin >> difficulte;
      if (difficulte == "facile") {
        cout << Chimie::askQuestion(easy, easy.size()) << "/" << easy.size() << "\n\n";
      } else if (difficulte == "medium") {
        cout << Chimie::askQuestion(medium, medium.size()) << "/" << medium.size() << "\n\n";
      } else if (difficulte == "difficile") {
        cout << Chimie::askQuestion(hard, hard.size()) << "/" << hard.size() << "\n\n";
      } else {
        cout << "Invalide \n\n";
      }
    } else if (command == "info") {
      // demander quel type de recherche
      string type; cout << "Souhaites-tu trouver par: nom (commande: nom) , symbole atomique (comande: symbole) ou numero atomique (commande: numero) \n \n"; cin >> type;
      //if its find by name
      if (type == "nom") {
        try {
          cout << "entre le nom de l'elemement (pas d'accents ex: Neon)\n \n";
          string _nom;cin >> _nom;
          cout << endl;
          // error handling for getting element
          if (Chimie::findElementByName(_nom) == nullptr) {
            cout << "Incapable de trouver l'element \n";
          } else {
            Element* element_ = Chimie::findElementByName(_nom);
            Chimie::printValues(element_);
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "numero") {
        // 
        string numero; cout << "Quel numero? \n \n"; cin >> numero;
        int num = stoi(numero);
        try {
          if (all[num] == 0) {
            cout << "Incapable de trouver l'element \n";
          } else {
           Chimie::printValues(all[num]); 
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "symbole") {
        cout << "entre le symbole atomique ( pas d'accents ex: Co )\n \n";
        string symbole;cin >> symbole;
        cout << endl;
        try {
          // error handling for getting element
          if (Chimie::findElementBySymbol(symbole) == nullptr) {
            cout << "Incapable de trouver l'element \n";
          } else {
            Chimie::printValues(Chimie::findElementBySymbol(symbole));
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "import") {
          Chimie::printValues(imported);
        }  else {
        cout << "Mode de saisie invalide. \n";
      }
    } else if(command == "creer_compose") {
      // trouve les elements dans la base de donne et cree une equation
      try {
        string element1; string element2;
        cout << "Element 1: "; cin >> element1; cout << "Element 2: ";  cin >> element2;
        Element* Element1_ = Chimie::findElementByName(element1);
        Element* Element2_ = Chimie::findElementByName(element2);
        // error handling
        if (Element1_ == nullptr || Element2_ == nullptr) {
          cout << "Incapable de trouver l'element \n";
        } else {
          Compose* UserCompose = new Compose(Element1_, Element2_);
          UserCompose->printCompose();
        }
      } catch(...) {
        cout << "Incapable de trouver l'element \n";
      }
    } else if (command == "cookie") {
      cout << "\nWow... Bravo d'avoir trouver le secret de chimie++, viens me voir avec une preuve (screenshot) et je vais t'acheter un biscuit a la cafeteria :)\n\n";
    } else if (command == "importer") {
      cout << "Entre le chemin vers ton fichier .txt (ex: ~/Chimie-ui-implemented-version/elementFiles/Hydrogene.txt): \n \n";
      
      string path; cin >> path;
      Chimie::importElement(path);
      cout << "Ton element est maintenant disponible dans la commande: info import \n";
    } else if (command == "trouver_gi") {
      cout << "\nQuel est le nom de l'element? \n\n";
      string elementName; cin >> elementName;
      if (Chimie::findElementByName(elementName)) {
        Element* result = Chimie::findElementByName(elementName)->trouver_gi_proche();
        Chimie::printValues(result);
      } else {
        cout << "\nInacapable de trouver l'element\n\n";
      }
      
    } else if (command == "tout") {
      for (Element * element : all) {
        Chimie::printValues(element);
      }
    } else if (command == "systeme") {
      cout << Chimie::getOsName() << endl << endl;
    } else if (command == "temps") {
        auto current = chrono::system_clock::now();
        time_t current_time = chrono::system_clock::to_time_t(current);
        cout << ctime(&current_time) << endl;
    } else if (command == "netoie") {
      int result = system("clear");
      if (result == 1) {
        result = system("cls");
      }
    } else if(command == "credits") {
      cout << "Version: 1.3 \n\
Copyright: No-one \n\
Licence: GNU GPL \n\
Dev team: Julien Renaud \n\
Testers: Xavier Dyer \n\
Ui designer: Julien \n\
Libraries used: stdlib, fstream \n\
Website: http://www.chimieplusplus.com \n\
Compatible with: Linux, MacOS, Replit \n\
Thank you for downloading the project!\n";
    } else if (command == "sortir" || command == "^C") {
      // sortir de l'app
      cout << "|¯¯¯\\  \\   /  |¯¯¯¯¯ \n";
      cout << "|   /   \\ /   |        • \\|/ \n";
      cout << "|---     |    |-----      c ) \n";
      cout << "|   \\    |    |        • /|\\ \n";
      cout << "|___/    |    |_____ \n";
      break;
    } else {
      cout << "Incapable de trouver la commande :/ \n \n";
    }
    command = "";
    times++;
  } // END OF INFINITE WHILE
} // END OF MAIN FUNCTION

int main() {
  app();
}#include <vector>
#include <cmath>
#include <string>
#include <chrono>
#include <thread>
#include "define.h"
using namespace std::this_thread;
using namespace std::chrono;
using namespace std;

string Chimie::boolToFrench(bool ibool) {
  if (ibool) {
    return "Oui";
  } else if (!ibool) {
    return "Non";
  }
  return "?";
}

string Chimie::getLewis(Element* element) {
  switch (element->electronsDeValence) {
    case 0:
      
    break;
    case 1:

    break;
    case 2:

    break;
    case 3:

    break;
    case 4:

    break;
    case 5: 

    break;
    case 6:

    break;
    case 7:

    break;
    case 8:

    break;
    case 9:

    break;
    case 10:

    break;
    case 11:

    break;
    case 12:

    break;
    default:
      cout << "Invalid electrons\n\n";
  }
}

bool Chimie::inVector(vector<int> vec, int number) {
  for (int x : vec) {
    if (number == x) {
      return true;
    }
  }
  return false;
}

bool Chimie::inVectorString(vector<string> vec, string number) {
  for (string x : vec) {
    if (number == x) {
      return true;
    }
  }
  return false;
}

string Chimie::lowerString(string input) {
  string alphabet = "abcdefghijklmnopqrstuvwxyz";
  string higherAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  int index1 = 0;
  for (char ichar : input) {
    int index = 0;
    for (char letter : higherAlphabet) {
      if (letter == ichar) {
        input[index1] = alphabet[index];
      }
      index++;
    }
    index1++;
  }
  return input;
}

void Chimie::loading(int millisecond) {
  long long oneMillisec = 1000000;
  for(int x = 0; x < 101; x++) {
    sleep_for(nanoseconds(millisecond * oneMillisec));
    int result = system("clear");;
    std::cout << "Chargement "<< x << "%\n";
  }
  std::cout << "Fini de charger!\n";
}

// constructor
Element::Element(string symboleAtomique_, string nomP, int nombreAtomique, int masseAtomique, int charge_, int valence) {
  // set properties of object
  nom = nomP;
  electrons = nombreAtomique;
  // electrons de valence, neutrons and protons are init by init()
  // set the electrons de valence property
  if (valence == 100) {
    for (pair<int, vector<int>> electrons_fams : elementFamilies) {
      bool done = false;
      for (int y : electrons_fams.second) {
        if (y == nombreAtomique) {
          famille = familles[electrons_fams.first].first;
          electronsDeValence = familles[electrons_fams.first].second;
          done = true;
          break;
        }
      }
      // end loop if done is true
      if (done) {break;}
    }
  } else {
    electronsDeValence = valence;
  }

  charge = charge_;
  nombreAtomique_ = nombreAtomique;
  masseAtomique_ = masseAtomique;
  symboleAtomique = symboleAtomique_;
}

Element * Element::stabiliser() {
  /*if (this->electrons <= 2) {
    int charge = this->electrons - 2;
    int full_el_gap = 2 - this->electronsDeValence;
    if (electrons < full_el_gap) {
      Element* result = new Element(this->symboleAtomique, this->nom, no_el_gap, no_el_gap);
      result->init();
      return result;
    } else {
      
    }
  }
*/
  return nullptr;
}

// Do this when you are done with stabiliser
Element* Element::trouver_gi_proche() {
  vector<int> gaps;
  for (Element * element : gi) {
    if (element->electrons - this->electrons > 0) {
      gaps.push_back(element->electrons - this->electrons);
    } else if (this->electrons - element->electrons > 0) {
      gaps.push_back(this->electrons - element->electrons);
    } else {
      gaps.push_back(this->electrons - element->electrons);
    }
  }
  int index = getMin(gaps);
  return gi[index];
}

// define a func to print all values of an element
void Chimie::printValues(Element* element) {
  cout << "|¯¯¯¯¯¯¯¯¯¯¯¯¯¯|\n";
  cout << "| " << element->electrons << "        " << element->charge << "  | \n";
  cout << "|      " << element->symboleAtomique << "      |\n";
  cout << "|              |\n";
  cout << "|    " << element->nom << "   |\n";
  cout << "|              |\n";
  cout << "|      " << element->masseAtomique_ << "      |\n";
  cout << "|______________|\n";
  
  cout << "Nom: " << element->nom << "\n";
  cout << "Symbole atomique: " << element->symboleAtomique << "\n";
  cout << "Numero atomique: " << element->nombreAtomique_ << "\n";
  cout << "Nombres d'electrons: " << element->electrons << "\n";
  cout << "Nombres de protons: " << element->protons << "\n";
  cout << "Nombres de neutrons: " << element->neutrons << "\n";
  cout << "Charge: " << element->charge << "\n";
  cout << "Electrons de valence: " << element->electronsDeValence << "\n";
  cout << "Masse atomique: " << element->masseAtomique_ << "\n";
  cout << "Metal: " /*<< boolalpha*/ << Chimie::boolToFrench(element->metal) << "\n" << "\n";
}

// definir une methode pour trouver le min car c++ est epais
int Element::getMin(vector<int> v) {
  int current_min = v[0];
  int index = 0;
  int final_index = 0;
  for (int number : v) {
    if (number < current_min) {
      current_min = number;
      final_index = index;
    }
    index++;
  }
  return final_index;
}

void Chimie::init() {
  for (Element* element : all) {
    // check if synth
    if (element->nombreAtomique_ > 104) {
      element->noCharge = true;
    } else {
      element->noCharge = false;
    }
    // if the element is synth then assing the electrons to proton value lol
    if (!element->noCharge) {
      element->protons = element->electrons + element->charge;
    } else {
      element->protons = element->electrons;
    }
    // see if its a metal or not
    if (element->charge > 0) {
      element->metal = true;
    } else {
      element->metal = false;
    }
    // if Hydrogene set gaz
    if (element->nom == "Hydrogene") {
      element->metal = false;
    }
    element->neutrons = element->masseAtomique_ - element->electrons;
  }
}

void Chimie::createElementFile(Element* element) {
  fstream elementFile;
  elementFile.open("elementFiles/" + element->nom + ".txt", ios::out); // open in write mode
  elementFile << "Nom: " << element->nom << endl;
  elementFile << "Symbole: " << element->symboleAtomique << endl;
  elementFile << "Electrons: " << element->electrons << endl;
  elementFile << "Protons: " << element->protons << endl;
  elementFile << "Neutrons: " << element->neutrons << endl;
  elementFile << "Charge: " << element->charge << endl;
  elementFile << "Numero atomique: " << element->nombreAtomique_ << endl;
  elementFile << "Masse atomique: " << element->masseAtomique_ << endl;
  elementFile << "Electrons de valence: " << element->electronsDeValence << endl;
  elementFile.close();
}

void Chimie::createFiles() {
  for (Element* element : all) {
    if (element->symboleAtomique != "") {
      Chimie::createElementFile(element);
    }
  }
}
void Element::init(Element* element) {
    // set the electrons de valence property
    if (element->charge < 0 && element->electrons > 2) {
      element->electronsDeValence = 8 - element->charge;
    } else if (element->charge > 0) {
      element->electronsDeValence = element->charge;
    }
    // check if synth
    if (element->nombreAtomique_ > 104) {
      element->noCharge = true;
    } else {
      element->noCharge = false;
    }
    // if the element is synth then assing the electrons to proton value lol
    if (!element->noCharge) {
      element->protons = element->electrons + element->charge;
    } else {
      element->electrons = element->protons;
    }
    // see if its a metal or not
    if (element->charge > 0) {
      element->metal = true;
    } else {
      element->metal = false;
    }
    // if Hydrogene set gaz
    if (element->nom == "Hydrogene") {
      element->metal = false;
    }
    element->neutrons = element->masseAtomique_ - element->electrons;
}

Element* Chimie::findElementByName(string name) {
  for (Element* element : all) {
    if (element->nom == name) {
      return element;
    }
  }
  return nullptr;
}

Element* Chimie::findElementBySymbol(string symbol) {
  for (Element* element : all) {
  if (element->symboleAtomique == symbol) {
    return element;
  }
  }
  return nullptr;
}

// lighter version of the class Compose (string format)
string creerCompose(Element* metal, Element* non_metal) {
  if (metal->noCharge || non_metal->noCharge) {
    cout << "Un ou plusieurs des metaux sont invalide desole \n";
  } else {
    int nMetal;
    int nNon_metal;
    nMetal = sqrt(pow(non_metal->charge, 2));
    nNon_metal = metal->charge;
    // if statement to make sure the equation doesnt contain the number 1 or 0
    if (nMetal <= 1) {
      if (nNon_metal <= 1) {
        return metal->symboleAtomique + non_metal->symboleAtomique;
      } else if (nNon_metal > 1) {
        return metal->symboleAtomique + non_metal->symboleAtomique + to_string(nNon_metal);
      }
    } else if(nMetal > 1) {
      if (nNon_metal <= 1) {
        return metal->symboleAtomique + to_string(nMetal) + non_metal->symboleAtomique;
      } else if (nNon_metal > 1) {
        return metal->symboleAtomique + to_string(nMetal) + non_metal->symboleAtomique + to_string(nNon_metal);
      }
    }
  }
  return nullptr;
}

// Compose class part -----------------------------------------
Compose::Compose(Element* Element1, Element* Element2) {
  // make sure this isnt 2 metals
  if (Element1->metal && Element2->metal) {
    cout << "Desole, tu ne peux pas avoir 2 Metaux \n";
  } else {
      charge = Element1->charge + Element2->charge;
      if (Element1->nom == "Hydrogene" && !Element2->metal) {
        type = types[2];
      } else if (Element1->metal == true && Element2->metal == false) {
          type = types[0];
        } else {
          type = types[1];
        }
      // make sure u dont get {element}1
      int nEle2 = sqrt(pow(Element1->charge, 2));
      int nEle1 = sqrt(pow(Element2->charge, 2));
      // set the charge too while u have amnt of every el in compose
      charge = Element1->charge * nEle1 + Element2->charge * nEle2;
      if (charge == 0) {
        stable = true;
      } else {
        stable = false;
      }
    
      if (nEle1 <= 1) {
        if (nEle2 <= 1) {
          formule = Element1->symboleAtomique + Element2->symboleAtomique;
        } else {
          formule = Element1->symboleAtomique + Element2->symboleAtomique + to_string(nEle2);
        }
      } else {
        if (nEle2 <= 1) {
          formule = Element1->symboleAtomique + to_string(nEle1) + Element2->symboleAtomique;
        } else {
          formule = Element1->symboleAtomique + to_string(nEle1) + Element2->symboleAtomique + to_string(nEle2);
        }
      }
  }
}

// define a method to print all the values of a compose
void Compose::printCompose() {
  cout << endl;
  cout << "Charge: " << this->charge << endl;
  cout << "Type: " << this->type << endl;
  cout << "Formule: " << this->formule << endl << endl;
}

string Chimie::crop(string input, int start, int end) {
  if (end == 0) {
    end=input.length();
  }
  string result;
  for (int x = start; x < end; x++) {
    result += input[x];
  }
  return result;
}

Element* Chimie::importElement(string filename) {
  fstream file;
  file.open(filename, ios::in);
  string line;
  vector<string> text;
  while (std::getline(file, line)) {
    text.push_back(line);
  }
  string nom = Chimie::crop(text[0], 5);
  string symbole = Chimie::crop(text[1], 9);
  int numeroAtomique = stoi(Chimie::crop(text[2], 11));
  int masseAtomique = stoi(Chimie::crop(text[7], 16));
  int charge = stoi(Chimie::crop(text[5], 8));
  imported = new Element(symbole, nom, numeroAtomique, masseAtomique, charge);
  imported->init(imported);
  return imported;
}

void Chimie::Init() {
  Chimie::init();
  Chimie::createFiles();
}

string Chimie::getOsName()
{
    #ifdef _WIN32
    return "Windows 32-bit";
    #elif _WIN64
    return "Windows 64-bit";
    #elif __APPLE__ || __MACH__
    return "Mac OSX";
    #elif __linux__
    return "Linux";
    #elif __FreeBSD__
    return "FreeBSD";
    #elif __unix || __unix__
    return "Unix";
    #else
    return "Other";
    #endif
}   

int Chimie::askQuestion(vector<pair<string, vector<string>>> questions, int times) {
  int total = 0;
  vector<int> usedQ;
  for (int x = 0; x < times; x++) {
    cout << endl;
    int index;
    do {
      index = rand() % questions.size(); // get random question
    } while (inVector(usedQ, index));
    pair<string, vector<string>> question = questions[index];
    cout << question.first << "\n\n"; // ask the question
    string answer; cin >> answer; // get user answer
    cout << endl;
    if (Chimie::inVectorString(question.second, answer)) {
      total += 1;
    } else {
      total += 0;
    }
    usedQ.push_back(index);
    cout << "\n";
  }
  return total;
}

/*
Version: 1.3
Copyright: No-one
Licence: GNU GPL
Dev team: Julien Renaud
Testers: Xavier Dyer
Ui designer: Julien
External libraries used: iostream, fstream
Website: http://www.chimieplusplus.com
Compatible with: Linux, MacOS, Replit
Thank you for downloading the project!
*/

#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

int stable [7] = {2, 10, 18, 36, 54, 86, 118};
vector<pair<int, int> > familles = {make_pair(0, 0), make_pair(1, 1), make_pair(2, 2), make_pair(3, 3), make_pair(4, 4), make_pair(5, 5), make_pair(6, 6), make_pair(7, 7), make_pair(8, 8), make_pair(9, 9), make_pair(10, 10), make_pair(11, 1), make_pair(12, 2), make_pair(13, 3), make_pair(14, 4), make_pair(15, 5), make_pair(16, 6), make_pair(17, 7)};
vector<pair<int, vector<int>>> elementFamilies = {make_pair(0, vector<int> {0, 0, 0, 0}), make_pair(1, vector<int>{1, 3, 11, 19, 37, 55, 87}), make_pair(2, vector<int>{4, 12, 20, 38, 56, 88}), make_pair(3, vector<int>{21, 39, 57, 89}), make_pair(4, vector<int>{22, 40, 72, 104}), make_pair(5, vector<int>{23, 41, 73, 105}), make_pair(6, vector<int>{24, 42, 74, 106}), make_pair(7, vector<int>{25, 43, 75, 107}), make_pair(8, vector<int>{26, 44, 76, 108}), make_pair(9, vector<int>{27, 45, 77, 109}), make_pair(10, vector<int>{28, 46, 78, 110}), make_pair(11, vector<int>{29, 47, 79, 111}), make_pair(12, vector<int>{30, 48, 80, 112}), make_pair(13, vector<int>{5, 13, 31, 49, 81, 113}), make_pair(14, vector<int>{6, 14, 32, 50, 82, 114}), make_pair(15, vector<int>{7, 15, 33, 51, 83, 115}), make_pair(16, vector<int>{8, 16, 34, 52, 84, 116}), make_pair(17, vector<int>{9, 17, 35, 53, 85, 117}), make_pair(18, vector<int>{2, 10, 18, 36, 54, 86, 118})};

class Element {
public:
  // define constructor
  Element(string symboleAtomique_, string nomP, int nombreAtomique, int masseAtomique, int charge_, int valence=100);
  // define all the properties of the atom
  string nom;
  int electrons;
  int protons;
  int neutrons;
  int charge;
  int nombreAtomique_;
  int masseAtomique_;
  int famille;
  string symboleAtomique;
  bool metal;
  int electronsDeValence;
  bool noCharge;

  virtual Element * stabiliser();
  static int getMin(vector<int> v);
  virtual Element * trouver_gi_proche();
  // only call this method if the element isnt part of the 'all' vector
  virtual void init(Element* element);
};

void setCharge(Element* element) {
  element->charge = element->electrons - element->trouver_gi_proche()->electrons;
}

// i wanted to write Composé but cpp wont let me
class Compose {
public:
  vector<string> types = {"ionique", "moleculaire", "acide", "base"};
  int charge;
  string type;
  bool stable;
  string formule;
  void printCompose();

  Compose(Element* Element1, Element* Element2);
};
// define an element where the user el can be stored
Element* imported;
// define all elements
// symbole, NOM, nombre atomique, masse atomique, charge
Element* Useless = new Element("", "USED TO FILL INDEX 0 in vector", 0, 0, 0);
Element* Hydrogene = new Element("H", "Hydrogene", 1, 1, -1);
Element* Helium = new Element("He", "Helium", 2, 4, 0);
Element* Lithium = new Element("Li", "Lithium", 3, 7, 1);
Element* Beryllium = new Element("Be", "Beryllium", 4, 9, 2);
Element* Bore = new Element("B", "Bore", 5, 11, -3);
Element* Carbone = new Element("C", "Carbone", 6, 12, -4);
Element* Azote = new Element("N", "Azote", 7, 14, -3);
Element* Oxygene = new Element("O", "Oxygene", 8, 16, -2);
Element* Fluor = new Element("F", "Fluor", 9, 16, -1);
Element* Neon = new Element("Ne", "Neon", 10, 20, 0);
Element* Sodium = new Element("Na", "Sodium", 11, 23, 1);
Element* Magnesium = new Element("Mg", "Magnesium", 12, 24, 2);
Element* Aluminium = new Element("Al", "Aluminium", 13, 27, 3);
Element* Silicium = new Element("Si", "Silicium", 14, 28, 4);
Element* Phosphore = new Element("P", "Phosphore", 15, 31, -3);
Element* Soufre = new Element("S", "Soufre", 16, 32, -2);
Element* Chlore = new Element("Cl", "Chlore", 17, 35, -1);
Element* Argon = new Element("Ar", "Argon", 18, 40, 0);
Element* Potassium = new Element("K", "Potassium", 19, 39, 1);
Element* Calcium = new Element("Ca", "Calcium", 20, 40, 2);
Element* Scandium = new Element("Sc", "Scandium", 21, 45, 3);
Element* Titane = new Element("Ti", "Titane", 22, 48, 4);
Element* Vanadium = new Element("V", "Vanadium", 23, 51, 5);
Element* Chrome = new Element("Cr", "Chrome", 24, 52, 3);
Element* Manganese = new Element("Mn", "Manganese", 25, 55, 3);
Element* Fer = new Element("Fe", "Fer", 26, 56, 3);
Element* Cobalt = new Element("Co", "Cobalt", 27, 59, 3);
Element* Nickel = new Element("Ni", "Nickel", 28, 59, 3);
Element* Cuivre = new Element("Cu", "Cuivre", 29, 64, 2);
Element* Zinc = new Element("Zn", "Zinc", 30, 65, 2);
Element* Gallium = new Element("Ga", "Gallium", 31, 70, 3);
Element* Germanium = new Element("Ge", "Germanium", 32, 73, 4);
Element* Arsenic = new Element("As", "Arsenic", 33, 75, -3);
Element* Selenium = new Element("Se", "Selenium", 34, 79, -2);
Element* Brome = new Element("Br", "Brome", 35, 80, -1);
Element* Krypton = new Element("Kr", "Krypton", 36, 84, 0);
Element* Rubidium = new Element("Rb", "Rubidium", 37, 85, 1);
Element* Strontium = new Element("Sr", "Strotnium", 38, 88, 2);
Element* Yttrium = new Element("Y", "Yttrium", 39, 89, 3);
Element* Zirconium = new Element("Zr", "Zirconium", 40, 91, 4);
Element* Niobium = new Element("Nb", "Niobium", 41, 93, 5);
Element* Molybdene = new Element("Mo", "Molybdene", 42, 96, 3);
Element* Technetium = new Element("Tc", "Technetium", 43, 98, 7);
Element* Ruthenium = new Element("Ru", "Ruthenium", 44, 102, 4);
Element* Rhodium = new Element("Rh", "Rhodium", 45, 103, 4);
Element* Palladium = new Element("Pd", "Palladium", 46, 106, 4);
Element* Argent = new Element("Ag", "Argent", 47, 108, 1);
Element* Cadmium = new Element("Cd", "Cadmium", 48, 112, 2);
Element* Indium = new Element("In", "Indium", 49, 115, 3);
Element* Etain = new Element("Sn", "Etain", 50, 119, 4);
Element* Antimoine = new Element("Sb", "Antimoine", 51, 122, 5);
Element* Tellure = new Element("Te", "Tellure", 52, 128, -2);
Element* Iode = new Element("I", "Iode", 53, 127, -1);
Element* Xenon = new Element("Xe", "Xenon", 54, 131, 0);
Element* Cesium = new Element("Cs", "Cesium", 55, 133, 1);
Element* Baryum = new Element("Ba", "Baryum", 56, 137, 2);
Element* Lanthane = new Element("La", "Lanthane", 57, 139, 3);
Element* Cerium = new Element("Ce", "Cerium", 58, 140, 4, 0);
Element* Praseodyme = new Element("Pr", "Praseodyme", 59, 141, 4, 0);
Element* Neodyme = new Element("Nd", "Neodyme", 60, 144, 3);
Element* Promethium = new Element("Pm", "Promethium", 61, 145, 3, 0);
Element* Samarium = new Element("Sm", "Samarium", 62, 150, 4, 0);
Element* Europium = new Element("Eu", "Europium", 63, 152, 3, 0);
Element* Gadolinium = new Element("Gd", "Gadolinium", 64, 157, 3, 0);
Element* Terbium = new Element("Tb", "Terbium", 65, 159, 4, 0);
Element* Dysprosium = new Element("Dy", "Dysporsium", 66, 160, 3, 0);
Element* Holmium = new Element("Ho", "Holmium", 67, 165, 3, 0);
Element* Erbium = new Element("Er", "Erbium", 68, 167, 3, 0);
Element* Thulium = new Element("Tm", "Thulium", 69, 169, 3, 0);
Element* Ytterbium = new Element("Yb", "Ytterbium", 70, 173, 3, 0);
Element* Lutecium = new Element("Lu", "Lutecium", 71, 175, 3);
Element* Hafnium = new Element("Hf", "Hafnium", 72, 178, 4);
Element* Tantale = new Element("Ta", "Tantale", 73, 181, 5);
Element* Tungstene = new Element("W", "Tungstene", 74, 184, 6);
Element* Rhenium = new Element("Re", "Rhenium", 75, 186, 7);
Element* Osmium = new Element("Os", "Osmium", 76, 190, 4);
Element* Iridium = new Element("Ir", "Iridium", 77, 192, 4);
Element* Platine = new Element("Pt", "Platine", 78, 195, 4);
Element* Or = new Element("Au", "Or", 79, 197, 3);
Element* Mercure = new Element("Hg", "Mercure", 80, 200, 2);
Element* Thallium = new Element("Tl", "Thallium", 81, 204, 3);
Element* Plomb = new Element("Pb", "Plomb", 82, 207, 4);
Element* Bismuth = new Element("Bi", "Bismuth", 83, 209, 5);
Element* Polonium = new Element("Po", "Polonium", 84, 209, 4);
Element* Astate = new Element("At", "Astate", 85, 210, -1);
Element* Radon = new Element("Rn", "Radon", 86, 222, 0);
Element* Francium = new Element("Fr", "Francium", 87, 223, 1);
Element* Radium = new Element("Ra", "Radium", 88, 226, 2);
Element* Actinium = new Element("Ac", "Actinium", 89, 227, 3, 0);
Element* Thorium = new Element("Th", "Thorium", 90, 232, 4, 0);
Element* Protactinium = new Element("Pa", "Protactinium", 91, 231, 5, 0);
Element* Uranium = new Element("U", "Uranium", 92, 238, 4, 0);
Element* Neptunium = new Element("Np", "Neptunium", 93, 237, 4, 0);
Element* Plutonium = new Element("Pu", "Plutonium", 94, 244, 4, 0);
Element* Americium = new Element("Am", "Americium", 95, 241, 4, 0);
Element* Curium = new Element("Cm", "Curium", 96, 247, 3, 0);
Element* Berkelium = new Element("Bk", "Berkelium", 97, 247, 4, 0);
Element* Californium = new Element("Cf", "Californium", 98, 251, 3, 0);
Element* Einsteinium = new Element("Es", "Einsteinium", 99, 252, 3, 0);
Element* Fermium = new Element("Fm", "Fermium", 100, 257, 3, 0);
Element* Mendelevium = new Element("Md", "Mendelevium", 101, 258, 3, 0);
Element* Nobelium = new Element("No", "Nobelium", 102, 259, 3, 0);
Element* Lawrencium = new Element("Lr", "Lawrencium", 103, 262, 3, 0);
Element* Rutherfordium = new Element("Rf", "Rutherfordium", 104, 261, 4);
Element* Dubnium = new Element("Db", "Dubnium", 105, 262, 0);
Element* Seaborgium = new Element("Sg", "Seaborgium", 106, 266, 0);
Element* Bohrium = new Element("Bh", "Bohrium", 107, 264, 0);
Element* Hassium = new Element("Hs", "Hassium", 108, 269, 0);
Element* Meithnerium = new Element("Mt", "Meithnerium", 109, 268, 0);
Element* Darmstadtium = new Element("Ds", "Darmastadium", 110, 281, 0);
Element* Roentgenium = new Element("Rg", "Roentgenium", 111, 280, 0);
Element* Copernicium = new Element("Uub", "Ununbium", 112, 285, 0);
Element* Ununtrium = new Element("Uut", "Unutrium", 113, 284, 0);
Element* Flerovium = new Element("Uuq", "Ununquadium", 114, 289, 0);
Element* Ununpentium = new Element("Uup", "Ununpentium", 115, 288, 0);
Element* Livermorium = new Element("Uuh", "Ununhexium", 116, 293, 0);
Element* Ununseptium = new Element("Uus", "Ununseptium", 117, 291, 0);
Element* Ununoctium = new Element("Uuo", "Ununoctium", 118, 294, 0);
// define a vector of all elements :(
vector<Element*> all = {Useless, Hydrogene, Helium, Lithium, Beryllium, Bore, Carbone, Azote, Oxygene, Fluor, Neon, Sodium, Magnesium, Aluminium, Silicium, Phosphore, Soufre, Chlore, Argon, Potassium, Calcium, Scandium, Titane, Vanadium, Chrome, Manganese, Fer, Cobalt, Nickel, Cuivre, Zinc, Gallium, Germanium, Arsenic, Selenium, Brome, Krypton, Rubidium, Strontium, Yttrium, Zirconium, Niobium, Molybdene, Technetium, Ruthenium, Rhodium, Palladium, Argent, Cadmium, Indium, Etain, Antimoine, Tellure, Iode, Xenon, Cesium, Baryum, Lanthane, Cerium, Praseodyme, Neodyme, Promethium, Samarium, Europium, Gadolinium, Terbium, Dysprosium, Holmium, Erbium, Thulium, Ytterbium, Lutecium, Hafnium, Tantale, Tungstene, Rhenium, Osmium, Iridium, Platine, Or, Mercure, Thallium, Plomb, Bismuth, Polonium, Astate, Radon, Francium, Radium, Actinium, Thorium, Protactinium, Uranium, Neptunium, Plutonium, Americium, Curium, Berkelium, Californium, Einsteinium, Fermium, Mendelevium, Nobelium, Lawrencium, Rutherfordium, Dubnium, Seaborgium, Bohrium, Hassium, Meithnerium, Darmstadtium, Roentgenium, Copernicium, Ununtrium, Flerovium, Ununpentium, Livermorium, Ununseptium, Ununoctium};
vector<Element*> gi = {Hydrogene, Neon, Argon, Krypton, Xenon, Radon, Ununoctium};

class Chimie {
  public:
    static string boolToFrench(bool ibool);
    static void loading(int millisecond);
    static void printValues(Element* element);
    static void init();
    static void createElementFile(Element* element);
    static void createFiles();
    static Element* findElementByName(string name);
    static Element* findElementBySymbol(string symbol);
    static string crop(string input, int start, int end=0);
    static Element* importElement(string filename);
    static void Init();
    static string getOsName();
    static int askQuestion(vector<pair<string, vector<string>>> questions, int times);
    static bool inVector(vector<int> vec, int number);
    static bool inVectorString(vector<string> vec, string number);
    static string lowerString(string input);
    static string getLewis(Element* element);
};

vector<pair<string, vector<string>>> easy = {make_pair("Quel est la particule subatomique avec un charge neutre?\n", vector<string> {"neutron", "neutrons"}),
make_pair("Quel est la propriete qui determine les electrons de valence?\n", vector<string> {"periode", "collone"}),
make_pair("Quel est la charge des gaz inhertes?\n", vector<string> {"0", "zero"}),
make_pair("Combiens d'element y a-il en total\n", vector<string> {"118"}),
make_pair("Quel particule subatomique a une charge negative?\n", vector<string> {"electron", "Electron", "electrons", "Electrons"}),
make_pair("Les electrons situe sur la couche externe d'electrons sont les electrons de _______\n", vector<string> {"valence", "Valence"}),
make_pair("Pour qu'un ion soit stable, il faut que sa couche de valence soit pleine ou ____\n", vector<string> {"vide", "Vide"}),
make_pair("pH veux dire puissance d'_________\n", vector<string> {"hydrogene", "Hydrogene"}),
make_pair("Quel est le le premier element du tableau périodique", vector<string> {"hydrogene", "Hydrogene"})};

vector<pair<string, vector<string>>> medium = {
make_pair("Combiens de carbone y a-il dans de l'heptane\n", vector<string> {"7", "sept"}),
make_pair("Quel est la formule chimique de l'Acide Iodhydrique (non stabilise)\n", vector<string> {"HI", "hi"}),
make_pair("Le MgOH est un acide ou une base?\n", vector<string> {"base", "Base"}),
make_pair("Une substance avec un pH de 1.2 est un(e) _____\n", vector<string> {"acide", "Acide"})};

vector<pair<string, vector<string>>> hard = {
  make_pair("HCl + NaOH -> NaCl + ___", vector<string> {"h20", "H20"}),
  make_pair("Quel est l'element numero 47", vector<string> {"Ag", "ag", "Argent", "argent"})
};# run this from the root directory of the project
cat chimie.cpp > utilities/totalcode.txt
cd chimie
cat define.cpp >> ../utilities/totalcode.txt
cat define.h >> ../utilities/totalcode.txt
cat ../utilities/countLines.sh >> ../utilities/totalcode.txt
cd ..
cd encoder
cat encoder.cpp >> ../utilities/totalcode.txt
cat encoder.h >> ../utilities/totalcode.txt
cd ..
cd utilities
cat totalcode.txt | wc -l #include "encoder.h"

string encoder::vector_to_string(vector<char> v) { 
  string s(v.begin(), v.end());
  return s;
}

int encoder::write(string filename, string _string, char method='a') {
  if (method == 'a') {
    fstream file; file.open(filename, ios_base::app);
    file << _string;
    file.close();
  } else {
    fstream file; file.open(filename, ios::out);
    file << _string;
    file.close();
  }
  return 0;
}

string encoder::encode(string _string) {
  vector<char> _result;
  for (char character : _string) {
    for (pair<char, char> _pair : letters) {
      if (character == _pair.first) {
        _result.push_back(_pair.second);
        break;
      }
    }
  }
  return this->vector_to_string(_result);
}

string encoder::translate(string encoded) {
  vector<char> _result;
  int x = 0;
  for (char character : encoded) {
    for (pair<char, char> _pair : letters) {
      if (character == _pair.second) {
        _result.push_back(_pair.first);
        break;
      }
    }
    x++;
  }
  return this->vector_to_string(_result);
}

vector<string> encoder::read(string filename) {
  fstream file; file.open(filename, ios::in);
  string line;
  vector<string> lines;
  while (getline(file, line)) {
    lines.push_back(this->translate(line));
  }
  return lines;
}#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#define p(x,y) make_pair(x,y)
using namespace std;

class encoder {
  private:
    vector<pair<char, char>> letters = {
      make_pair('a',char(1)), make_pair('b',char(3)), make_pair('c',char(2)), make_pair('d',char(5)), p('d',char(6)), p('e',char(4)), p('f',char(7)), p('g',char(9)), p('h',char(11)), p('i',char(10)), p('j',char(8)), p('k',char(13)), p('l',char(12)), p('m',char(14)), p('n',char(15)), p('o',char(16)), p('p',char(17)), p('q',char(20)), p('r',char(19)), p('s',char(18)), p('t',char(24)), p('u',char(22)), p('v',char(23)), p('w',char(21)), p('x',char(26)), p('y',char(25)), p('z',char(27)), p(' ',char(28))
    };
  public:
    string encode(string _string);
    string translate(string encoded);
    string vector_to_string(vector<char> v);
    int write(string filename, string _string, char method);
    vector<string> read(string filename);
};