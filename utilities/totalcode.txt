#include <iostream>
#include <ctime>
#include <chrono>
#include <cctype>
#include "chimie/define.cpp"
#include "encoder/encoder.cpp"
using namespace std;

// welcome to chimie++!
void app() {
  Chimie_login::logged_in();
  while (!is_logged_in) {
    vector<string> users = Encoder->read("encoder/.users");
    if (!users.empty()) {
      cout << "Aimerais-tu te: connecter ou enregistrer\n";
      string command; cin >> command;
      if (Encoder->read("encoder/.users") != vector<string>{""} && command == "connecter") {
        cout << "\nConnection:\n";
        string password; string username;
        cout << "Entre ton nom d'utilisateur: "; cin >> username; cout << "Entre ton mot de passe: "; cin >> password;
        if (username.length() > 4 && password.length() > 6) {
          Chimie_login::login(username, password);
        } else {
          cout << "Desole, ton nom d'utilisateur est invalide. (Le nom d'utilisateur doit avoir au moins 4 characteres)\n";
        }
      } else {
        cout << "\nEnregistrer:\n";
        string password; string username;
        cout << "Entre ton nom d'utilisateur: "; cin >> username; cout << "Entre ton mot de passe: "; cin >> password;
        if (password != "" && username != "") { 
          if (!Chimie_login::already_used(username)) {
            Chimie_login::register_user(username, password);
          } else {
            cout << "Ton nom d'utilisateur est deja utilise\n\n";
          }
        } else {
          cout << "Tu dois remplir chaque case.\n";
        }
      }
    } else {
      cout << "Il y a aucun utilisateur d'enregistre dans la base de donnee\n";
      cout << "\nEnregistrer:\n";
      string password; string username;
      cout << "Entre ton nom d'utilisateur: "; cin >> username; cout << "Entre ton mot de passe: "; cin >> password;
      if (password != "" && username != "") {
        if (!Chimie_login::already_used(username)) {
          Chimie_login::register_user(username, password);
        } else {
          cout << "Ton nom d'utilisateur est deja utilise\n\n";
        }
      } else {
        cout << "Tu dois remplir chaque case.\n";
      }
    }
  }
  int user_id = Chimie_login::get_user_id();
  Chimie::Init();
  // Begining dialog
  //Chimie::loading(25);
    cout << "Bienvenue "+Chimie_login::get_values("encoder/.cache", 1)[0]+"!\n";
  cout << "\n         .        .   \n";
  cout << "/¯¯ |  | | |\\  /| | |¯¯¯¯      |       |\n";
  cout << "|   |--| | | \\/ | | |----   ---|--- ---|---\n";
  cout << "\\__ |  | | |    | | |____      |       |\n";
  cout << "Bienvenue a Chimie++ (version terminal)\n";
  cout << "La raison qu'il n'y a pas d'accents est que certains OS ne montrent pas bien les accents et ecrivent du griboulli.\n";
  cout << "Qu'aimerais-tu faire? (en passant, tu peux avoir une liste des commandes avec le mot 'aide') \n";

  string command;
  int times = 1;
  // UI principal
  while (is_logged_in) {
    // get users command until sortir
    if (times > 1) {
      cout << "Entre une " << times << "eme commande: ";
    } else {
      cout << "Entre une commande: ";
    }
    cin >> command; cout << endl;
    Chimie_login::update_count("encoder/.users", user_id, 1);
    Chimie_login::update_count("encoder/.cache", 1, 1);
    command = Chimie::lowerString(command);
    if (command == "aide") {
      // list all commands
      cout << "Voici une liste de commande: \n \n";
      cout << "sortir: Fermer l'application \n \n";
      cout << "info: Te donne tout l'information necessaire a propos d'un element\n \n";
      cout << "importer: Importe un element sous format d'element dans fichier .txt (voir template.txt) a partir d'un chemin vers le fichier .txt\n \n";
      cout << "creer_compose: cree un compose ionique ou moleculaire equilibre a partire de deux elements \n \n";
      cout << "netoie: efface tout le texte qui est presentement sur l'ecran\n\n"; 
      cout << "trouver_gi: indique quel est le gaz inerte le plus proche de l'element\n\n";
      cout << "quiz: un outil de pratique pour la chimie\n\n";
      cout << "systeme: retourne le nom de ton OS \n\n";
      cout << "temps: indique l'heure exacte\n\n";
      cout << "tout: liste tout les elements\n\n";
      cout << "effacer: efface tout les comptes de la base de donnees\n\n";
      cout << "stats: affiche tes statistiques\n\n";
      cout << "telecharger: telecharge les donnees d'un element dans un fichier choisi\n\n";
      cout << "logout: Te deconnecte de ton compte\n\ncredits: montre les credits\n\n";
    } else if (command == "quiz") { 
      cout << "Quel niveau de difficulte? [facile, medium, difficile]\n\n";
      string difficulte; cin >> difficulte;
      if (difficulte == "facile") {
        cout << Chimie::askQuestion(easy, easy.size()) << "/" << easy.size() << "\n\n";
      } else if (difficulte == "medium") {
        cout << Chimie::askQuestion(medium, medium.size()) << "/" << medium.size() << "\n\n";
      } else if (difficulte == "difficile") {
        cout << Chimie::askQuestion(hard, hard.size()) << "/" << hard.size() << "\n\n";
      } else {
        cout << "Invalide \n\n";
      }
    } else if (command == "info") {
      // demander quel type de recherche
      string type; cout << "Souhaites-tu trouver par: nom (commande: nom) , symbole atomique (comande: symbole) ou numero atomique (commande: numero) \n \n"; cin >> type;
      //if its find by name
      if (type == "nom") {
        try {
          cout << "entre le nom de l'elemement (pas d'accents ex: Neon)\n \n";
          string _nom;cin >> _nom;
          cout << endl;
          // error handling for getting element
          if (Chimie::findElementByName(_nom) == nullptr) {
            cout << "Incapable de trouver l'element \n";
          } else {
            Element* element_ = Chimie::findElementByName(_nom);
            Chimie::printValues(element_);
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "numero") {
        // 
        string numero; cout << "Quel numero? \n \n"; cin >> numero;
        int num = stoi(numero);
        try {
          if (all[num] == 0) {
            cout << "Incapable de trouver l'element \n";
          } else {
           Chimie::printValues(all[num]); 
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "symbole") {
        cout << "entre le symbole atomique ( pas d'accents ex: Co )\n \n";
        string symbole;cin >> symbole;
        cout << endl;
        try {
          // error handling for getting element
          if (Chimie::findElementBySymbol(symbole) == nullptr) {
            cout << "Incapable de trouver l'element \n";
          } else {
            Chimie::printValues(Chimie::findElementBySymbol(symbole));
          }
        } catch(...) {
          cout << "Incapable de trouver l'element \n";
        }
      } else if (type == "import") {
          Chimie::printValues(imported);
        }  else {
        cout << "Mode de saisie invalide. \n";
      }
    } else if (command == "logout") {
      Chimie_login::logout();
      break;
    } else if (command == "effacer") {
      Encoder->write("encoder/.users", "", 'w');
      Chimie_login::logout();
      break;
    } else if(command == "creer_compose") {
      // trouve les elements dans la base de donne et cree une equation
      try {
        string element1; string element2;
        cout << "Element 1: "; cin >> element1; cout << "Element 2: ";  cin >> element2;
        Element* Element1_ = Chimie::findElementByName(element1);
        Element* Element2_ = Chimie::findElementByName(element2);
        // error handling
        if (Element1_ == nullptr || Element2_ == nullptr) {
          cout << "Incapable de trouver l'element \n";
        } else {
          Compose* UserCompose = new Compose(Element1_, Element2_);
          if (Element1_->metal && Element2_->metal) {

          } else {
            UserCompose->printCompose();
          }
        }
      } catch(...) {
        cout << "Incapable de trouver l'element \n";
      }
    } else if (command == "cookie") {
      cout << "\nWow... Bravo d'avoir trouver le secret de chimie++, viens me voir avec une preuve (screenshot) et je vais t'acheter un biscuit a la cafeteria :)\n\n";
    } else if (command == "importer") {
      cout << "Entre le chemin vers ton fichier .txt (ex: ~/Chimie-ui-implemented-version/elementFiles/Hydrogene.txt): \n \n";
      
      string path; cin >> path;
      Chimie::importElement(path);
      cout << "Ton element est maintenant disponible dans la commande: info import \n";
    } else if (command == "trouver_gi") {
      cout << "\nQuel est le nom de l'element? \n\n";
      string elementName; cin >> elementName;
      if (Chimie::findElementByName(elementName)) {
        Element* result = Chimie::findElementByName(elementName)->trouver_gi_proche();
        Chimie::printValues(result);
      } else {
        cout << "\nInacapable de trouver l'element\n\n";
      }
      
    } else if (command == "tout") {
      for (Element * element : all) {
        Chimie::printValues(element);
      }
    } else if (command == "systeme") {
      cout << Chimie::getOsName() << endl << endl;
    } else if (command == "temps") {
        auto current = chrono::system_clock::now();
        time_t current_time = chrono::system_clock::to_time_t(current);
        cout << ctime(&current_time) << endl;
    } else if (command == "netoie") {
      int result = system("clear");
      if (result == 1) {
        result = system("cls");
      }
    } else if (command == "about_me") {
      cout << "Desole, cette comande est seulement accessible au developeur\n\n";//"username: "+Chimie_login::logged_in()->get_info()[0]+" password: "+Chimie_login::logged_in()->get_info()[1]+"\n";
    } else if (command == "telecharger") {
      string name; cout << "Quel est le nom de l'elelement?\n\n"; cin >> name;
      string filename; cout << "Quel est le chemin du fichier ou tu aimerais sauvegarder l'element (relatif ou non-relatif)\n\n"; cin >> filename;// continue this and add debugging so if the filepath is wrong well dont do it :D
      system(("touch "+filename).c_str());
      fstream test; test.open(filename);
      if (test.is_open() && Chimie::findElementByName(name)) {
        Chimie::downloadElement(Chimie::findElementByName(name), filename);
      } else {
        cout << test.is_open() << endl;
        cout << "Erreur: Le chemin de fichier est invalide ou l'element est invalide \n\n";
      }
    } else if (command == "stats") {
      vector<string> user_values = Chimie_login::get_values("encoder/.users", user_id);
      cout << "Username: "+user_values[0]+" \nAmmount of searches: "+user_values[2]+"\n\n";
    } else if(command == "credits") {
      cout << "Version: 1.3 \n\
Copyright: No-one \n\
Licence: GNU GPL \n\
Dev team: Julien Renaud \n\
Testers: Xavier Dyer \n\
Ui designer: Julien \n\
Libraries used: stdlib, fstream \n\
Website: http://www.chimieplusplus.com \n\
Compatible with: Linux, MacOS, Replit \n\
Thank you for downloading the project!\n";
    } else if (command == "sortir" || command == "^C") {
      // sortir de l'app
      cout << "|¯¯¯\\  \\   /  |¯¯¯¯¯ \n";
      cout << "|   /   \\ /   |      \n";
      cout << "|---     |    |-----  \n";
      cout << "|   \\    |    |      \n";
      cout << "|___/    |    |_____ \n";
      break;
    } else {
      cout << "Incapable de trouver la commande :/ \n \n";
    }
    command = "";
    times++;
  } // END OF INFINITE WHILE
} // END OF MAIN FUNCTION

int main() {
  app();
}

// edit setup file (make it dowloadable using curl hehe)#include <vector>
#include <cmath>
#include <string>
#include <chrono>
#include <thread>
#include "define.h"
using namespace std::this_thread;
using namespace std::chrono;
using namespace std;

string Chimie::boolToFrench(bool ibool) {
  if (ibool) {
    return "Oui";
  } else if (!ibool) {
    return "Non";
  }
  return "?";
}

bool Chimie::inVector(vector<int> vec, int number) {
  for (int x : vec) {
    if (number == x) {
      return true;
    }
  }
  return false;
}

bool Chimie::inVectorString(vector<string> vec, string number) {
  for (string x : vec) {
    if (number == x) {
      return true;
    }
  }
  return false;
}

string Chimie::lowerString(string input) {
  string alphabet = "abcdefghijklmnopqrstuvwxyz";
  string higherAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  int index1 = 0;
  for (char ichar : input) {
    int index = 0;
    for (char letter : higherAlphabet) {
      if (letter == ichar) {
        input[index1] = alphabet[index];
      }
      index++;
    }
    index1++;
  }
  return input;
}

void Chimie::loading(int millisecond) {
  long long oneMillisec = 1000000;
  for(int x = 0; x < 101; x++) {
    sleep_for(nanoseconds(millisecond * oneMillisec));
    int result = system("clear");;
    std::cout << "Chargement "<< x << "%\n";
  }
  std::cout << "Fini de charger!\n";
}

// constructor
Element::Element(string symboleAtomique_, string nomP, int nombreAtomique, int masseAtomique, int charge_, int valence) {
  // set properties of object
  nom = nomP;
  electrons = nombreAtomique;
  // electrons de valence, neutrons and protons are init by init()
  // set the electrons de valence property
  if (valence == 100) {
    for (pair<int, vector<int>> electrons_fams : elementFamilies) {
      bool done = false;
      for (int y : electrons_fams.second) {
        if (y == nombreAtomique) {
          famille = familles[electrons_fams.first].first;
          electronsDeValence = familles[electrons_fams.first].second;
          done = true;
          break;
        }
      }
      // end loop if done is true
      if (done) {break;}
    }
  } else {
    electronsDeValence = valence;
  }

  charge = charge_;
  nombreAtomique_ = nombreAtomique;
  masseAtomique_ = masseAtomique;
  symboleAtomique = symboleAtomique_;
}

Element * Element::stabiliser() {
  /*if (this->electrons <= 2) {
    int charge = this->electrons - 2;
    int full_el_gap = 2 - this->electronsDeValence;
    if (electrons < full_el_gap) {
      Element* result = new Element(this->symboleAtomique, this->nom, no_el_gap, no_el_gap);
      result->init();
      return result;
    } else {
      
    }
  }
*/
  return nullptr;
}

// Do this when you are done with stabiliser
Element* Element::trouver_gi_proche() {
  vector<int> gaps;
  for (Element * element : gi) {
    if (element->electrons - this->electrons > 0) {
      gaps.push_back(element->electrons - this->electrons);
    } else if (this->electrons - element->electrons > 0) {
      gaps.push_back(this->electrons - element->electrons);
    } else {
      gaps.push_back(this->electrons - element->electrons);
    }
  }
  int index = getMin(gaps);
  return gi[index];
}

// define a func to print all values of an element
void Chimie::printValues(Element* element) {
  cout << "|¯¯¯¯¯¯¯¯¯¯¯¯¯¯|\n";
  cout << "| " << element->electrons << "        " << element->charge << "  | \n";
  cout << "|      " << element->symboleAtomique << "      |\n";
  cout << "|              |\n";
  cout << "|    " << element->nom << "   |\n";
  cout << "|              |\n";
  cout << "|      " << element->masseAtomique_ << "      |\n";
  cout << "|______________|\n";
  
  cout << "Nom: " << element->nom << "\n";
  cout << "Symbole atomique: " << element->symboleAtomique << "\n";
  cout << "Numero atomique: " << element->nombreAtomique_ << "\n";
  cout << "Nombres d'electrons: " << element->electrons << "\n";
  cout << "Nombres de protons: " << element->protons << "\n";
  cout << "Nombres de neutrons: " << element->neutrons << "\n";
  cout << "Charge: " << element->charge << "\n";
  cout << "Electrons de valence: " << element->electronsDeValence << "\n";
  cout << "Masse atomique: " << element->masseAtomique_ << "\n";
  cout << "Metal: " /*<< boolalpha*/ << Chimie::boolToFrench(element->metal) << "\n" << "\n";
}

// definir une methode pour trouver le min car c++ est epais
int Element::getMin(vector<int> v) {
  int current_min = v[0];
  int index = 0;
  int final_index = 0;
  for (int number : v) {
    if (number < current_min) {
      current_min = number;
      final_index = index;
    }
    index++;
  }
  return final_index;
}

void Chimie::init() {
  for (Element* element : all) {
    // check if synth
    if (element->nombreAtomique_ > 104) {
      element->noCharge = true;
    } else {
      element->noCharge = false;
    }
    // if the element is synth then assing the electrons to proton value lol
    if (!element->noCharge) {
      element->protons = element->electrons + element->charge;
    } else {
      element->protons = element->electrons;
    }
    // see if its a metal or not
    if (element->charge > 0) {
      element->metal = true;
    } else {
      element->metal = false;
    }
    // if Hydrogene set gaz
    if (element->nom == "Hydrogene") {
      element->metal = false;
    }
    element->neutrons = element->masseAtomique_ - element->electrons;
  }
}

void Chimie::createElementFile(Element* element) {
  fstream elementFile;
  elementFile.open("elementFiles/" + element->nom + ".txt", ios::out); // open in write mode
  elementFile << "Nom: " << element->nom << endl;
  elementFile << "Symbole: " << element->symboleAtomique << endl;
  elementFile << "Electrons: " << element->electrons << endl;
  elementFile << "Protons: " << element->protons << endl;
  elementFile << "Neutrons: " << element->neutrons << endl;
  elementFile << "Charge: " << element->charge << endl;
  elementFile << "Numero atomique: " << element->nombreAtomique_ << endl;
  elementFile << "Masse atomique: " << element->masseAtomique_ << endl;
  elementFile << "Electrons de valence: " << element->electronsDeValence << endl;
  elementFile.close();
}

void Chimie::createFiles() {
  for (Element* element : all) {
    if (element->symboleAtomique != "") {
      Chimie::createElementFile(element);
    }
  }
}
void Element::init(Element* element) {
    // set the electrons de valence property
    if (element->charge < 0 && element->electrons > 2) {
      element->electronsDeValence = 8 - element->charge;
    } else if (element->charge > 0) {
      element->electronsDeValence = element->charge;
    }
    // check if synth
    if (element->nombreAtomique_ > 104) {
      element->noCharge = true;
    } else {
      element->noCharge = false;
    }
    // if the element is synth then assing the electrons to proton value lol
    if (!element->noCharge) {
      element->protons = element->electrons + element->charge;
    } else {
      element->electrons = element->protons;
    }
    // see if its a metal or not
    if (element->charge > 0) {
      element->metal = true;
    } else {
      element->metal = false;
    }
    // if Hydrogene set gaz
    if (element->nom == "Hydrogene") {
      element->metal = false;
    }
    element->neutrons = element->masseAtomique_ - element->electrons;
}

Element* Chimie::findElementByName(string name) {
  for (Element* element : all) {
    if (element->nom == name) {
      return element;
    }
  }
  return nullptr;
}

Element* Chimie::findElementBySymbol(string symbol) {
  for (Element* element : all) {
  if (element->symboleAtomique == symbol) {
    return element;
  }
  }
  return nullptr;
}

// lighter version of the class Compose (string format)
string creerCompose(Element* metal, Element* non_metal) {
  if (metal->noCharge || non_metal->noCharge) {
    cout << "Un ou plusieurs des metaux sont invalide desole \n";
  } else {
    int nMetal;
    int nNon_metal;
    nMetal = sqrt(pow(non_metal->charge, 2));
    nNon_metal = metal->charge;
    // if statement to make sure the equation doesnt contain the number 1 or 0
    if (nMetal <= 1) {
      if (nNon_metal <= 1) {
        return metal->symboleAtomique + non_metal->symboleAtomique;
      } else if (nNon_metal > 1) {
        return metal->symboleAtomique + non_metal->symboleAtomique + to_string(nNon_metal);
      }
    } else if(nMetal > 1) {
      if (nNon_metal <= 1) {
        return metal->symboleAtomique + to_string(nMetal) + non_metal->symboleAtomique;
      } else if (nNon_metal > 1) {
        return metal->symboleAtomique + to_string(nMetal) + non_metal->symboleAtomique + to_string(nNon_metal);
      }
    }
  }
  return nullptr;
}

// Compose class part -----------------------------------------
Compose::Compose(Element* Element1, Element* Element2) {
  // make sure this isnt 2 metals
  if (Element1->metal && Element2->metal) {
    cout << "Desole, tu ne peux pas avoir 2 Metaux \n";
  } else {
      charge = Element1->charge + Element2->charge;
      if (Element1->nom == "Hydrogene" && !Element2->metal) {
        type = types[2];
      } else if (Element1->metal == true && Element2->metal == false) {
          type = types[0];
        } else {
          type = types[1];
        }
      // make sure u dont get {element}1
      int nEle2 = sqrt(pow(Element1->charge, 2));
      int nEle1 = sqrt(pow(Element2->charge, 2));
      // set the charge too while u have amnt of every el in compose
      charge = Element1->charge * nEle1 + Element2->charge * nEle2;
      if (charge == 0) {
        stable = true;
      } else {
        stable = false;
      }
    
      if (nEle1 <= 1) {
        if (nEle2 <= 1) {
          formule = Element1->symboleAtomique + Element2->symboleAtomique;
        } else {
          formule = Element1->symboleAtomique + Element2->symboleAtomique + to_string(nEle2);
        }
      } else {
        if (nEle2 <= 1) {
          formule = Element1->symboleAtomique + to_string(nEle1) + Element2->symboleAtomique;
        } else {
          formule = Element1->symboleAtomique + to_string(nEle1) + Element2->symboleAtomique + to_string(nEle2);
        }
      }
  }
}

// define a method to print all the values of a compose
void Compose::printCompose() {
  cout << endl;
  cout << "Charge: " << this->charge << endl;
  cout << "Type: " << this->type << endl;
  cout << "Formule: " << this->formule << endl << endl;
}

string Chimie::crop(string input, int start, int end) {
  if (end == 0) {
    end=input.length();
  }
  string result;
  for (int x = start; x < end; x++) {
    result += input[x];
  }
  return result;
}

Element* Chimie::importElement(string filename) {
  fstream file;
  file.open(filename, ios::in);
  string line;
  vector<string> text;
  while (std::getline(file, line)) {
    text.push_back(line);
  }
  string nom = Chimie::crop(text[0], 5);
  string symbole = Chimie::crop(text[1], 9);
  int numeroAtomique = stoi(Chimie::crop(text[2], 11));
  int masseAtomique = stoi(Chimie::crop(text[7], 16));
  int charge = stoi(Chimie::crop(text[5], 8));
  imported = new Element(symbole, nom, numeroAtomique, masseAtomique, charge);
  imported->init(imported);
  return imported;
}

void Chimie::Init() {
  Chimie::init();
  Chimie::createFiles();
}

string Chimie::getOsName()
{
    #ifdef _WIN32
    return "Windows 32-bit";
    #elif _WIN64
    return "Windows 64-bit";
    #elif __APPLE__ || __MACH__
    return "Mac OSX";
    #elif __linux__
    return "Linux";
    #elif __FreeBSD__
    return "FreeBSD";
    #elif __unix || __unix__
    return "Unix";
    #else
    return "Other";
    #endif
}   

int Chimie::askQuestion(vector<pair<string, vector<string>>> questions, int times) {
  int total = 0;
  vector<int> usedQ;
  for (int x = 0; x < times; x++) {
    cout << endl;
    int index;
    do {
      index = rand() % questions.size(); // get random question
    } while (inVector(usedQ, index));
    pair<string, vector<string>> question = questions[index];
    cout << question.first << "\n\n"; // ask the question
    string answer; cin >> answer; // get user answer
    cout << endl;
    if (Chimie::inVectorString(question.second, answer)) {
      total += 1;
    } else {
      total += 0;
    }
    usedQ.push_back(index);
    cout << "\n";
  }
  return total;
}

void Chimie::downloadElement(Element* element, string filepath) {
  fstream elementFile;
  elementFile.open(filepath, fstream::out);
  elementFile << "Nom: " << element->nom << endl;
  elementFile << "Symbole: " << element->symboleAtomique << endl;
  elementFile << "Electrons: " << element->electrons << endl;
  elementFile << "Protons: " << element->protons << endl;
  elementFile << "Neutrons: " << element->neutrons << endl;
  elementFile << "Charge: " << element->charge << endl;
  elementFile << "Numero atomique: " << element->nombreAtomique_ << endl;
  elementFile << "Masse atomique: " << element->masseAtomique_ << endl;
  elementFile << "Electrons de valence: " << element->electronsDeValence << endl;
  elementFile.close();
}

/*
Version: 1.3
Copyright: No-one
Licence: GNU GPL
Dev team: Julien Renaud
Testers: Xavier Dyer
Ui designer: Julien
External libraries used: iostream, fstream
Website: http://www.chimieplusplus.com
Compatible with: Linux, MacOS, Replit
Thank you for downloading the project!
*/

#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

int stable [7] = {2, 10, 18, 36, 54, 86, 118};
vector<pair<int, int> > familles = {make_pair(0, 0), make_pair(1, 1), make_pair(2, 2), make_pair(3, 3), make_pair(4, 4), make_pair(5, 5), make_pair(6, 6), make_pair(7, 7), make_pair(8, 8), make_pair(9, 9), make_pair(10, 10), make_pair(11, 1), make_pair(12, 2), make_pair(13, 3), make_pair(14, 4), make_pair(15, 5), make_pair(16, 6), make_pair(17, 7)};
vector<pair<int, vector<int>>> elementFamilies = {make_pair(0, vector<int> {0, 0, 0, 0}), make_pair(1, vector<int>{1, 3, 11, 19, 37, 55, 87}), make_pair(2, vector<int>{4, 12, 20, 38, 56, 88}), make_pair(3, vector<int>{21, 39, 57, 89}), make_pair(4, vector<int>{22, 40, 72, 104}), make_pair(5, vector<int>{23, 41, 73, 105}), make_pair(6, vector<int>{24, 42, 74, 106}), make_pair(7, vector<int>{25, 43, 75, 107}), make_pair(8, vector<int>{26, 44, 76, 108}), make_pair(9, vector<int>{27, 45, 77, 109}), make_pair(10, vector<int>{28, 46, 78, 110}), make_pair(11, vector<int>{29, 47, 79, 111}), make_pair(12, vector<int>{30, 48, 80, 112}), make_pair(13, vector<int>{5, 13, 31, 49, 81, 113}), make_pair(14, vector<int>{6, 14, 32, 50, 82, 114}), make_pair(15, vector<int>{7, 15, 33, 51, 83, 115}), make_pair(16, vector<int>{8, 16, 34, 52, 84, 116}), make_pair(17, vector<int>{9, 17, 35, 53, 85, 117}), make_pair(18, vector<int>{2, 10, 18, 36, 54, 86, 118})};

class Element {
public:
  // define constructor
  Element(string symboleAtomique_, string nomP, int nombreAtomique, int masseAtomique, int charge_, int valence=100);
  // define all the properties of the atom
  string nom;
  int electrons;
  int protons;
  int neutrons;
  int charge;
  int nombreAtomique_;
  int masseAtomique_;
  int famille;
  string symboleAtomique;
  bool metal;
  int electronsDeValence;
  bool noCharge;

  virtual Element * stabiliser();
  static int getMin(vector<int> v);
  virtual Element * trouver_gi_proche();
  // only call this method if the element isnt part of the 'all' vector
  virtual void init(Element* element);
};

void setCharge(Element* element) {
  element->charge = element->electrons - element->trouver_gi_proche()->electrons;
}

// i wanted to write Composé but cpp wont let me
class Compose {
public:
  vector<string> types = {"ionique", "moleculaire", "acide", "base"};
  int charge;
  string type;
  bool stable;
  string formule;
  void printCompose();

  Compose(Element* Element1, Element* Element2);
};
// define an element where the user el can be stored
Element* imported;
// define all elements
// symbole, NOM, nombre atomique, masse atomique, charge
Element* Useless = new Element("", "USED TO FILL INDEX 0 in vector", 0, 0, 0);
Element* Hydrogene = new Element("H", "Hydrogene", 1, 1, -1);
Element* Helium = new Element("He", "Helium", 2, 4, 0);
Element* Lithium = new Element("Li", "Lithium", 3, 7, 1);
Element* Beryllium = new Element("Be", "Beryllium", 4, 9, 2);
Element* Bore = new Element("B", "Bore", 5, 11, -3);
Element* Carbone = new Element("C", "Carbone", 6, 12, -4);
Element* Azote = new Element("N", "Azote", 7, 14, -3);
Element* Oxygene = new Element("O", "Oxygene", 8, 16, -2);
Element* Fluor = new Element("F", "Fluor", 9, 16, -1);
Element* Neon = new Element("Ne", "Neon", 10, 20, 0);
Element* Sodium = new Element("Na", "Sodium", 11, 23, 1);
Element* Magnesium = new Element("Mg", "Magnesium", 12, 24, 2);
Element* Aluminium = new Element("Al", "Aluminium", 13, 27, 3);
Element* Silicium = new Element("Si", "Silicium", 14, 28, 4);
Element* Phosphore = new Element("P", "Phosphore", 15, 31, -3);
Element* Soufre = new Element("S", "Soufre", 16, 32, -2);
Element* Chlore = new Element("Cl", "Chlore", 17, 35, -1);
Element* Argon = new Element("Ar", "Argon", 18, 40, 0);
Element* Potassium = new Element("K", "Potassium", 19, 39, 1);
Element* Calcium = new Element("Ca", "Calcium", 20, 40, 2);
Element* Scandium = new Element("Sc", "Scandium", 21, 45, 3);
Element* Titane = new Element("Ti", "Titane", 22, 48, 4);
Element* Vanadium = new Element("V", "Vanadium", 23, 51, 5);
Element* Chrome = new Element("Cr", "Chrome", 24, 52, 3);
Element* Manganese = new Element("Mn", "Manganese", 25, 55, 3);
Element* Fer = new Element("Fe", "Fer", 26, 56, 3);
Element* Cobalt = new Element("Co", "Cobalt", 27, 59, 3);
Element* Nickel = new Element("Ni", "Nickel", 28, 59, 3);
Element* Cuivre = new Element("Cu", "Cuivre", 29, 64, 2);
Element* Zinc = new Element("Zn", "Zinc", 30, 65, 2);
Element* Gallium = new Element("Ga", "Gallium", 31, 70, 3);
Element* Germanium = new Element("Ge", "Germanium", 32, 73, 4);
Element* Arsenic = new Element("As", "Arsenic", 33, 75, -3);
Element* Selenium = new Element("Se", "Selenium", 34, 79, -2);
Element* Brome = new Element("Br", "Brome", 35, 80, -1);
Element* Krypton = new Element("Kr", "Krypton", 36, 84, 0);
Element* Rubidium = new Element("Rb", "Rubidium", 37, 85, 1);
Element* Strontium = new Element("Sr", "Strotnium", 38, 88, 2);
Element* Yttrium = new Element("Y", "Yttrium", 39, 89, 3);
Element* Zirconium = new Element("Zr", "Zirconium", 40, 91, 4);
Element* Niobium = new Element("Nb", "Niobium", 41, 93, 5);
Element* Molybdene = new Element("Mo", "Molybdene", 42, 96, 3);
Element* Technetium = new Element("Tc", "Technetium", 43, 98, 7);
Element* Ruthenium = new Element("Ru", "Ruthenium", 44, 102, 4);
Element* Rhodium = new Element("Rh", "Rhodium", 45, 103, 4);
Element* Palladium = new Element("Pd", "Palladium", 46, 106, 4);
Element* Argent = new Element("Ag", "Argent", 47, 108, 1);
Element* Cadmium = new Element("Cd", "Cadmium", 48, 112, 2);
Element* Indium = new Element("In", "Indium", 49, 115, 3);
Element* Etain = new Element("Sn", "Etain", 50, 119, 4);
Element* Antimoine = new Element("Sb", "Antimoine", 51, 122, 5);
Element* Tellure = new Element("Te", "Tellure", 52, 128, -2);
Element* Iode = new Element("I", "Iode", 53, 127, -1);
Element* Xenon = new Element("Xe", "Xenon", 54, 131, 0);
Element* Cesium = new Element("Cs", "Cesium", 55, 133, 1);
Element* Baryum = new Element("Ba", "Baryum", 56, 137, 2);
Element* Lanthane = new Element("La", "Lanthane", 57, 139, 3);
Element* Cerium = new Element("Ce", "Cerium", 58, 140, 4, 0);
Element* Praseodyme = new Element("Pr", "Praseodyme", 59, 141, 4, 0);
Element* Neodyme = new Element("Nd", "Neodyme", 60, 144, 3);
Element* Promethium = new Element("Pm", "Promethium", 61, 145, 3, 0);
Element* Samarium = new Element("Sm", "Samarium", 62, 150, 4, 0);
Element* Europium = new Element("Eu", "Europium", 63, 152, 3, 0);
Element* Gadolinium = new Element("Gd", "Gadolinium", 64, 157, 3, 0);
Element* Terbium = new Element("Tb", "Terbium", 65, 159, 4, 0);
Element* Dysprosium = new Element("Dy", "Dysporsium", 66, 160, 3, 0);
Element* Holmium = new Element("Ho", "Holmium", 67, 165, 3, 0);
Element* Erbium = new Element("Er", "Erbium", 68, 167, 3, 0);
Element* Thulium = new Element("Tm", "Thulium", 69, 169, 3, 0);
Element* Ytterbium = new Element("Yb", "Ytterbium", 70, 173, 3, 0);
Element* Lutecium = new Element("Lu", "Lutecium", 71, 175, 3);
Element* Hafnium = new Element("Hf", "Hafnium", 72, 178, 4);
Element* Tantale = new Element("Ta", "Tantale", 73, 181, 5);
Element* Tungstene = new Element("W", "Tungstene", 74, 184, 6);
Element* Rhenium = new Element("Re", "Rhenium", 75, 186, 7);
Element* Osmium = new Element("Os", "Osmium", 76, 190, 4);
Element* Iridium = new Element("Ir", "Iridium", 77, 192, 4);
Element* Platine = new Element("Pt", "Platine", 78, 195, 4);
Element* Or = new Element("Au", "Or", 79, 197, 3);
Element* Mercure = new Element("Hg", "Mercure", 80, 200, 2);
Element* Thallium = new Element("Tl", "Thallium", 81, 204, 3);
Element* Plomb = new Element("Pb", "Plomb", 82, 207, 4);
Element* Bismuth = new Element("Bi", "Bismuth", 83, 209, 5);
Element* Polonium = new Element("Po", "Polonium", 84, 209, 4);
Element* Astate = new Element("At", "Astate", 85, 210, -1);
Element* Radon = new Element("Rn", "Radon", 86, 222, 0);
Element* Francium = new Element("Fr", "Francium", 87, 223, 1);
Element* Radium = new Element("Ra", "Radium", 88, 226, 2);
Element* Actinium = new Element("Ac", "Actinium", 89, 227, 3, 0);
Element* Thorium = new Element("Th", "Thorium", 90, 232, 4, 0);
Element* Protactinium = new Element("Pa", "Protactinium", 91, 231, 5, 0);
Element* Uranium = new Element("U", "Uranium", 92, 238, 4, 0);
Element* Neptunium = new Element("Np", "Neptunium", 93, 237, 4, 0);
Element* Plutonium = new Element("Pu", "Plutonium", 94, 244, 4, 0);
Element* Americium = new Element("Am", "Americium", 95, 241, 4, 0);
Element* Curium = new Element("Cm", "Curium", 96, 247, 3, 0);
Element* Berkelium = new Element("Bk", "Berkelium", 97, 247, 4, 0);
Element* Californium = new Element("Cf", "Californium", 98, 251, 3, 0);
Element* Einsteinium = new Element("Es", "Einsteinium", 99, 252, 3, 0);
Element* Fermium = new Element("Fm", "Fermium", 100, 257, 3, 0);
Element* Mendelevium = new Element("Md", "Mendelevium", 101, 258, 3, 0);
Element* Nobelium = new Element("No", "Nobelium", 102, 259, 3, 0);
Element* Lawrencium = new Element("Lr", "Lawrencium", 103, 262, 3, 0);
Element* Rutherfordium = new Element("Rf", "Rutherfordium", 104, 261, 4);
Element* Dubnium = new Element("Db", "Dubnium", 105, 262, 0);
Element* Seaborgium = new Element("Sg", "Seaborgium", 106, 266, 0);
Element* Bohrium = new Element("Bh", "Bohrium", 107, 264, 0);
Element* Hassium = new Element("Hs", "Hassium", 108, 269, 0);
Element* Meithnerium = new Element("Mt", "Meithnerium", 109, 268, 0);
Element* Darmstadtium = new Element("Ds", "Darmastadium", 110, 281, 0);
Element* Roentgenium = new Element("Rg", "Roentgenium", 111, 280, 0);
Element* Copernicium = new Element("Uub", "Ununbium", 112, 285, 0);
Element* Ununtrium = new Element("Uut", "Unutrium", 113, 284, 0);
Element* Flerovium = new Element("Uuq", "Ununquadium", 114, 289, 0);
Element* Ununpentium = new Element("Uup", "Ununpentium", 115, 288, 0);
Element* Livermorium = new Element("Uuh", "Ununhexium", 116, 293, 0);
Element* Ununseptium = new Element("Uus", "Ununseptium", 117, 291, 0);
Element* Ununoctium = new Element("Uuo", "Ununoctium", 118, 294, 0);
// define a vector of all elements :(
vector<Element*> all = {Useless, Hydrogene, Helium, Lithium, Beryllium, Bore, Carbone, Azote, Oxygene, Fluor, Neon, Sodium, Magnesium, Aluminium, Silicium, Phosphore, Soufre, Chlore, Argon, Potassium, Calcium, Scandium, Titane, Vanadium, Chrome, Manganese, Fer, Cobalt, Nickel, Cuivre, Zinc, Gallium, Germanium, Arsenic, Selenium, Brome, Krypton, Rubidium, Strontium, Yttrium, Zirconium, Niobium, Molybdene, Technetium, Ruthenium, Rhodium, Palladium, Argent, Cadmium, Indium, Etain, Antimoine, Tellure, Iode, Xenon, Cesium, Baryum, Lanthane, Cerium, Praseodyme, Neodyme, Promethium, Samarium, Europium, Gadolinium, Terbium, Dysprosium, Holmium, Erbium, Thulium, Ytterbium, Lutecium, Hafnium, Tantale, Tungstene, Rhenium, Osmium, Iridium, Platine, Or, Mercure, Thallium, Plomb, Bismuth, Polonium, Astate, Radon, Francium, Radium, Actinium, Thorium, Protactinium, Uranium, Neptunium, Plutonium, Americium, Curium, Berkelium, Californium, Einsteinium, Fermium, Mendelevium, Nobelium, Lawrencium, Rutherfordium, Dubnium, Seaborgium, Bohrium, Hassium, Meithnerium, Darmstadtium, Roentgenium, Copernicium, Ununtrium, Flerovium, Ununpentium, Livermorium, Ununseptium, Ununoctium};
vector<Element*> gi = {Hydrogene, Neon, Argon, Krypton, Xenon, Radon, Ununoctium};

class Chimie {
  public:
    static string boolToFrench(bool ibool);
    static void loading(int millisecond);
    static void printValues(Element* element);
    static void init();
    static void createElementFile(Element* element);
    static void createFiles();
    static Element* findElementByName(string name);
    static Element* findElementBySymbol(string symbol);
    static string crop(string input, int start, int end=0);
    static Element* importElement(string filename);
    static void Init();
    static string getOsName();
    static int askQuestion(vector<pair<string, vector<string>>> questions, int times);
    static bool inVector(vector<int> vec, int number);
    static bool inVectorString(vector<string> vec, string number);
    static string lowerString(string input);
    static string getLewis(Element* element);
    static void downloadElement(Element* element, string filepath);
};

vector<pair<string, vector<string>>> easy = {make_pair("Quel est la particule subatomique avec un charge neutre?\n", vector<string> {"neutron", "neutrons"}),
make_pair("Quel est la propriete qui determine les electrons de valence?\n", vector<string> {"periode", "collone"}),
make_pair("Quel est la charge des gaz inhertes?\n", vector<string> {"0", "zero"}),
make_pair("Combiens d'element y a-il en total\n", vector<string> {"118"}),
make_pair("Quel particule subatomique a une charge negative?\n", vector<string> {"electron", "Electron", "electrons", "Electrons"}),
make_pair("Les electrons situe sur la couche externe d'electrons sont les electrons de _______\n", vector<string> {"valence", "Valence"}),
make_pair("Pour qu'un ion soit stable, il faut que sa couche de valence soit pleine ou ____\n", vector<string> {"vide", "Vide"}),
make_pair("pH veux dire puissance d'_________\n", vector<string> {"hydrogene", "Hydrogene"}),
make_pair("Quel est le le premier element du tableau périodique", vector<string> {"hydrogene", "Hydrogene"})};

vector<pair<string, vector<string>>> medium = {
make_pair("Combiens de carbone y a-il dans de l'heptane\n", vector<string> {"7", "sept"}),
make_pair("Quel est la formule chimique de l'Acide Iodhydrique (non stabilise)\n", vector<string> {"HI", "hi"}),
make_pair("Le MgOH est un acide ou une base?\n", vector<string> {"base", "Base"}),
make_pair("Une substance avec un pH de 1.2 est un(e) _____\n", vector<string> {"acide", "Acide"})};

vector<pair<string, vector<string>>> hard = {
  make_pair("HCl + NaOH -> NaCl + ___", vector<string> {"h20", "H20"}),
  make_pair("Quel est l'element numero 47", vector<string> {"Ag", "ag", "Argent", "argent"})
};# run this from the root directory of the project
cat chimie.cpp > utilities/totalcode.txt
cd chimie
cat define.cpp >> ../utilities/totalcode.txt
cat define.h >> ../utilities/totalcode.txt
cat ../utilities/countLines.sh >> ../utilities/totalcode.txt
cd ..
cd encoder
cat encoder.cpp >> ../utilities/totalcode.txt
cat encoder.h >> ../utilities/totalcode.txt
cd ..
cd game
cat game.cpp >> ../utilities/totalcode.txt
cat game.h >> ../utilities/totalcode.txt
cat gameTest.cpp >> ../utilities/totalcode.txt
cd ..
cd utilities
cat countLines.sh >> totalcode.txt
cat totalcode.txt | wc -l
echo lines
cd ..#include "encoder.h"
#include <cstdio>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>

void printVector(vector<int> vec) {
  for (int x : vec) {
    cout << x << endl;
  }  
}

void printVector(vector<string> vec) {
  for (string x : vec) {
    cout << x << endl;
  }  
}

void printVector(vector<double> vec) {
  for (double x : vec) {
    cout << x << endl;
  }  
}

void printVector(vector<bool> vec) {
  for (bool x : vec) {
    cout << x << endl;
  }  
}

void printVector(vector<char> vec) {
  for (char x : vec) {
    cout << x << endl;
  }  
}

bool Chimie_login::has_char(string _string, char wanted) {
  for (char x : _string) {
    if (x == wanted) {
      return true;
    }
  }
  return false;
}

string encoder::vector_to_string(vector<char> v) { 
  string s(v.begin(), v.end());
  return s;
}

int encoder::write(string filename, string _string, char method='a') {
  if (method == 'a') {
    fstream file; file.open(filename, ios_base::app);
    file << _string;
    file.close();
  } else {
    fstream file; file.open(filename, ios::out);
    file << _string;
    file.close();
  }
  return 0;
}

string encoder::encode(string _string) {
  vector<char> _result;
  for (char character : _string) {
    for (pair<char, char> _pair : letters) {
      if (character == _pair.first) {
        _result.push_back(_pair.second);
        break;
      }
    }
  }
  return this->vector_to_string(_result);
}

string encoder::translate(string encoded) {
  vector<char> _result;
  int x = 0;
  for (char character : encoded) {
    for (pair<char, char> _pair : letters) {
      if (character == _pair.second) {
        _result.push_back(_pair.first);
        break;
      }
    }
    x++;
  }
  return this->vector_to_string(_result);
}

vector<string> encoder::read(string filename) {
  fstream file; file.open(filename, ios::in);
  string line;
  vector<string> lines;
  while (getline(file, line)) {
    lines.push_back(this->translate(line));
  }
  return lines;
}

string exec(const char* cmd) {
    array<char, 128> buffer;
    string result;
    unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

vector<string> Chimie_login::get_values(string filename, int line) {
  // command to get whats on the line (works fine)
  string tmp = "head -"+to_string(line)+" "+filename;
  // execute the command (works)
  string all = exec(tmp.c_str());
  // translate encoded into regular text
  string regular = Encoder->translate(all);
  vector<int> comma_locations = {-1};
  int index = 0;
  if (!regular.empty()) {
    for (char x : regular) {
      if (x == ',') {
        comma_locations.push_back(index);
      }
      index++;
    }
    comma_locations.push_back(regular.length());
    // printVector(comma_locations);
    vector<string> final;
    // WORKS UNTIL HERE :(
    for (int x = 0; x < comma_locations.size() - 1; x++) {
      final.push_back(regular.substr(comma_locations[x] + 1, comma_locations[x+1] - comma_locations[x] - 1));
    }
    return final;
    } else {
      cout << "Il n'y a pas de valeur sur cette ligne\n";
      return vector<string> {};
    }
}

void Chimie_login::update_count(string filename, int line, int value) {
  vector<string> before = get_values(filename, line);
  string new_ = before[0]+","+before[1]+","+to_string(stoi(before[2]) + value);
  fstream ifile; ifile.open(filename, ios::in); string line_; vector<string> lines;
  while(getline(ifile, line_)) {
    lines.push_back(line_);
  }
  lines.erase(lines.begin() + (line - 1));
  lines.insert(lines.begin() + (line - 1), Encoder->encode(new_));
  system(("> " + filename).c_str());
  for (string tmp : lines) {
    system(("echo '"+tmp+"' >> "+filename).c_str());
  }
}

int Chimie_login::get_user_id() {
  string logged_in = Encoder->read("encoder/.cache")[0];
  vector<string> all_users = Encoder->read("encoder/.users");
  int line = 0;
  for (string user : all_users) {
    line++;
    if (user == logged_in) {
      return line;
    }
  }
  return 0;
}

bool Chimie_login::already_used(string username) {
  vector<string> res = Encoder->read("encoder/.users");
  for (string x : res) {
    int length = username.length();
    string registered = x.substr(0, length);
    if (registered == username) {
      return true;
    }
  }
  return false;
}

User::User(string username, string password) {
  this->password = password;
  this->username = username;
}

User* Chimie_login::login(string username, string password) {
  vector<string> users = Encoder->read("encoder/.users");
  int current_line = 1;
  for (string x : users) {
    vector<string> user = get_values("encoder/.users", current_line);
    if (user[0]+","+user[1] == username+","+password) { 
      Encoder->write("encoder/.cache", Encoder->encode(username+","+password+","+user[2]), 'w');
      is_logged_in = true;
      return new User(username, password);
    }
    current_line++;
  }
  cout << "\nIl n'y existe pas de comptes avec ces donnees\n";
  return nullptr;
}

User* Chimie_login::register_user(string username, string password) {
  Encoder->write("encoder/.users", Encoder->encode(username)+","+Encoder->encode(password+","+to_string(0))+"\n");
  is_logged_in = true;
  Encoder->write("encoder/.cache", Encoder->encode(username+","+password+","+to_string(0)), 'w');
  return new User(username, password);
}

void Chimie_login::logout() {
  Encoder->write("encoder/.cache", "", 'w');
  is_logged_in = false;
}

User* Chimie_login::logged_in() {
  vector<string> user = get_values("encoder/.cache", 1);
  if (!user.empty()) {
    string username = user[0];
    string password = user[1];
    is_logged_in = true;
    return new User(username, password);
  } else {
    cout << "Aucun utilisateur est connecte\n";
    is_logged_in = false;
    return NULL;
  }
}

vector<string> User::get_info() {
  return vector<string> {this->username, this->password};
}#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#define p(x,y) make_pair(x,y)
using namespace std;

class User;

class encoder {
  private:
    vector<pair<char, char>> letters = {
      make_pair('a',char(1)), make_pair('b',char(3)), make_pair('c',char(2)), make_pair('d',char(5)), make_pair('d',char(6)), make_pair('e',char(4)), make_pair('f',char(7)), make_pair('g',char(9)), make_pair('h',char(11)), make_pair('i',char(29)), make_pair('j',char(8)), make_pair('k',char(129)), make_pair('l',char(12)), make_pair('m',char(14)), make_pair('n',char(15)), make_pair('o',char(16)), make_pair('p',char(17)), make_pair('q',char(20)), make_pair('r',char(19)), make_pair('s',char(18)), make_pair('t',char(24)), make_pair('u',char(22)), make_pair('v',char(23)), make_pair('w',char(21)), make_pair('x',char(26)), make_pair('y',char(25)), make_pair('z',char(27)), make_pair(char(32),char(28)), make_pair(char(44),char(44)), make_pair('A',char(29)), make_pair('B',char(31)), make_pair('C',char(30)), make_pair('D',char(32)), make_pair('E',char(33)), make_pair('F',char(35)), make_pair('G',char(34)), make_pair('H',char(36)), make_pair('I',char(37)), make_pair('J',char(38)), make_pair('K',char(39)), make_pair('L',char(41)), make_pair('M',char(40)), make_pair('N',char(42)), make_pair('O',char(43)), make_pair('P',char(45)), make_pair('Q',char(46)), make_pair('R',char(48)), make_pair('S',char(47)), make_pair('T',char(49)), make_pair('U',char(50)), make_pair('V',char(51)), make_pair('W',char(52)), make_pair('X',char(53)), make_pair('Y',char(54)), make_pair('Z',char(55)), make_pair('1',char(56)), make_pair('2',char(57)), make_pair('3',char(58)), make_pair('4',char(59)), make_pair('5',char(60)), make_pair('6',char(61)), make_pair('7',char(62)), make_pair('8',char(64)), make_pair('9',char(63)), make_pair('0',char(65)), make_pair('-',char(66)), make_pair('=',char(67)), make_pair('!',char(68)), make_pair(char(34),char(69)), make_pair('£',char(70)), make_pair('$',char(71)), make_pair('%',char(73)), make_pair('^',char(72)), make_pair('&',char(74)), make_pair('*',char(75)), make_pair('(',char(76)), make_pair(')',char(77)), make_pair('_',char(79)), make_pair('+',char(78)), make_pair(char(96),char(80)), make_pair('¬',char(81)), make_pair('¦',char(82)), make_pair(']',char(89)), make_pair('{',char(90)), make_pair('}',char(91)), make_pair(';',char(92)), make_pair('~',char(95)), make_pair('<',char(96)), make_pair('>',char(97)), make_pair('.',char(98)), make_pair('/',char(99)), make_pair('?',char(100)), make_pair('\\',char(101)), make_pair('|',char(102)), make_pair('@',char(103))
    };
  public:
    string encode(string _string);
    string translate(string encoded);
    string vector_to_string(vector<char> v);
    int write(string filename, string _string, char method);
    vector<string> read(string filename);
};

class User {
  private:
    string username;
    string password;
    encoder* Encoder = new encoder();
  public:
    User(string username, string password);
    bool logged_in = true;
    vector<string> get_info();
};
bool is_logged_in;
encoder* Encoder = new encoder();
class Chimie_login {
  public:
    static User* login(string username, string password);
    static User* register_user(string username, string password);
    static void logout();
    static User* logged_in();
    static bool already_used(string username);
    static bool has_char(string _string, char wanted);
    static vector<string> get_values(string filename, int line);
    static void update_count(string filename, int line, int value);
    static int get_user_id();
};#include "game.h"
#include <stdlib.h>

Element* game::guess() {
  int index = rand() % 3 + 0;
  return elements[index];
}

Element* game::get_ui() {
  cout << "Fer, Oxygene ou Zinc?\n";
  string choix; cin >> choix;
  if (choix == "sortir") {
    return Carbone;
  }
  return Chimie::findElementByName(choix);
}

void game() {
  cout << "Started\n";
  while (true) {
    Element* computer = game::guess();
    Element* user = game::get_ui();
    if (user != nullptr) {
      if (user == Carbone) {
        break;
      }
      Chimie::printValues(computer);
      if (user->nom == "Oxygene" && computer->nom == "Fer" || user->nom == "Fer" && computer->nom == "Zinc" || user->nom == "Zinc" && computer->nom == "Oxygene") {
        // user wins
        cout << "Bravo!\n";
      } else if (user->nom == computer->nom) {
        // tie
        cout << "Egalitee\n";
      } else {
        // user loses
        cout << "Desole, tu as perdu\n";
      }
    } else {
      cout << "Nom d'element non-valide\n";
    }
  }
}#include "../chimie/define.cpp"

Element* elements[3] = {Fer, Oxygene, Zinc};
class game {
  public:
    
    static Element* guess();
    static Element* get_ui(); // user input
    //static void greet();
    //static void rules();
};#include "game.cpp"

int main() {
  game();
}# run this from the root directory of the project
cat chimie.cpp > utilities/totalcode.txt
cd chimie
cat define.cpp >> ../utilities/totalcode.txt
cat define.h >> ../utilities/totalcode.txt
cat ../utilities/countLines.sh >> ../utilities/totalcode.txt
cd ..
cd encoder
cat encoder.cpp >> ../utilities/totalcode.txt
cat encoder.h >> ../utilities/totalcode.txt
cd ..
cd game
cat game.cpp >> ../utilities/totalcode.txt
cat game.h >> ../utilities/totalcode.txt
cat gameTest.cpp >> ../utilities/totalcode.txt
cd ..
cd utilities
cat countLines.sh >> totalcode.txt
cat totalcode.txt | wc -l
echo lines
cd ..